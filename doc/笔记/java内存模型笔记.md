
# java内存结构分析--运行时数据区
 ## Method Area--所有线程共享的数据区
   ### 常量池
   ### 类静态变量
   ### 类成员变量
   ### 类的类型信息、构造函数、方法信息等。
 ## heap--所有线程共享的数据区
   ### 存储java实例或者对象的地方，是GC的主要区域
 ## vm stack--线程隔离的数据区
   ### 栈帧：当线程执行到某个方法时就会往方线程中压入一个栈帧。栈帧包含了方法的局部变量表，操作数栈，返回地址，动态链接等信息。
   vm stack和线程是紧密联系的，每创建一个线程时就会对应创建一个vm stack，
   所以vm stack也是"线程私有"的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方
   法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法
   从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程。
   虚拟机栈是一个后入先出的数据结构，线程运行过程中，只有一个栈帧是处于活跃状态的，被称为"当前活动帧栈"，
   当前活动帧栈始终是虚拟机栈的栈顶元素。
 ## native method stack--线程隔离的数据区
   本地方法栈与虚拟机栈发挥的功能非常类似，只是虚拟机栈为虚拟机执行java方法而服务，
   而本地方法栈为虚拟机执行native方法而服务。
 ## program counter register--线程隔离的数据区
   程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保存着当前线程执行
   的虚拟机字节码指令的内存地址。Java多线程的实现，其实是通过线程间的轮流切换并分配处理器
   执行时间的方式来实现的，在任何时刻，处理器都只会执行一个线程中的指令。在多线程场景下，
   为了保证线程切换回来后，还能恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一
   个程序计数器，并且各个线程之间不会互相影响，程序计数器为"线程私有"的内存区域。
   如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，如果正在执行
   的是Native方法（非Java方法，JVM底层有许多非Java编写的函数实现），计数器则为空。程序
   计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。
# 参考文档：https://www.cnblogs.com/jiyukai/p/6665199.html

  *JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中
  开辟了一块区域存放运行时常量池。
  常量池：
    字面量：
      文本字符串
      被声明为final的常量值
      基本数据类型的值
      其他
    符号引用：
      类和结构的完全限定名
      子段名称和描述符
      方法名称和描述符
  
  *JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。
  下面是一些常用参数：
  -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
  -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
  与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
  为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?
  整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的
  限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最
  大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义
  元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
  当然这只是其中一个原因，还有很多底层的原因，这里就不提了
  
 ## Metaspace--直接内存
   ### 类的加载信息
 ## heap--所有线程共享的数据区
   ### 存储java实例或者对象的地方，是GC的主要区域
   ### 常量池
   ### 静态变量
 ## vm stack--线程隔离的数据区
   ### 栈帧
 ## native method stack--线程隔离的数据区
 ## program counter register--线程隔离的数据区
 
 ## 关于静态变量存放于heap还是metaspace
 public class c1{
 
     private static Long[] a = new Long[99999999];
     ......
     
     public static void main (String[]args){
          new C1();
     }
 }