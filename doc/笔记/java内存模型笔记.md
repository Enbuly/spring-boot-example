
# java内存结构分析--运行时数据区
 ## Method Area--所有线程共享的数据区
   ### 常量池
   ### 类静态变量
   ### 类成员变量
   ### 类的类型信息、构造函数、方法信息等。
 ## heap--所有线程共享的数据区
   ### 存储java实例或者对象的地方，是GC的主要区域
 ## vm stack--线程隔离的数据区
   ### 栈帧：当线程执行到某个方法时就会往方线程中压入一个栈帧。栈帧包含了方法的局部变量表，操作数栈，返回地址，动态链接等信息。
   vm stack和线程是紧密联系的，每创建一个线程时就会对应创建一个vm stack，
   所以vm stack也是"线程私有"的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方
   法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法
   从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程。
   虚拟机栈是一个后入先出的数据结构，线程运行过程中，只有一个栈帧是处于活跃状态的，被称为"当前活动帧栈"，
   当前活动帧栈始终是虚拟机栈的栈顶元素。
 ## native method stack--线程隔离的数据区
   本地方法栈与虚拟机栈发挥的功能非常类似，只是虚拟机栈为虚拟机执行java方法而服务，
   而本地方法栈为虚拟机执行native方法而服务。
 ## program counter register--线程隔离的数据区
   程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保存着当前线程执行
   的虚拟机字节码指令的内存地址。Java多线程的实现，其实是通过线程间的轮流切换并分配处理器
   执行时间的方式来实现的，在任何时刻，处理器都只会执行一个线程中的指令。在多线程场景下，
   为了保证线程切换回来后，还能恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一
   个程序计数器，并且各个线程之间不会互相影响，程序计数器为"线程私有"的内存区域。
   如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，如果正在执行
   的是Native方法（非Java方法，JVM底层有许多非Java编写的函数实现），计数器则为空。程序
   计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。
# 参考文档：https://www.cnblogs.com/jiyukai/p/6665199.html